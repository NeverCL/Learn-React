# 简介

[官方文档](https://doc.react-china.org/docs/hello-world.html)

## 准备

`npm i -S react react-dom`

`npm i babel-loader babel-preset-react -S`

```js
module: {
    rules: [{
        test: /\.(js|jsx)$/,
        loader: 'babel-loader',
        options: {
            presets: ['react']
        },
        exclude: /node_modules/
    }]
},
externals: {
    'react': 'React',
    'react-dom': 'ReactDOM'
},
```

```js
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
    <h1>Hello, world!</h1>,
    document.getElementById('root')
);
```

## 组件

```js
class HelloMessage extends React.Component {
    render() {
        return (
            <div>Hello {this.props.name}</div>
        )
    }
}

ReactDOM.render(
    <HelloMessage name="World" />,
    document.getElementById('root')
);
```

## JSX

写 JSX 的时候一般都会带上换行和缩进，这样可以增强代码的可读性

推荐在 JSX 代码的外面扩上一个小括号，这样可以防止 分号自动插入 的 bug

`const element = <img src={user.avatarUrl}></img>;`

当使用大括号包裹的 JavaScript 表达式时就不要再到外面套引号了。JSX 会将引号当中的内容识别为字符串而不是表达式。

`class tabindex` => `className tabIndex`

因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称

`const element = <h1>{title}</h1>;` // title 可直接使用

JSX 防注入攻击,防止 XSS(跨站脚本) 攻击。

```js
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
```

```js
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
);
```

```js
// 注意: 以下示例是简化过的（不代表在 React 源码中是这样）
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};
```

Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用

## 属性(props)

无论是使用函数或是类来声明一个组件，它决不能修改它自己的props。

```js
// 纯函数
function sum(a, b) {
  return a + b;
}

// 非纯函数
function withdraw(account, amount) {
  account.total -= amount;
}
```

所有的React组件必须像纯函数那样使用它们的props。

## 状态(state)

应用的界面是随时间动态变化的.

state可以在不违反上述规则的情况下，根据用户操作、网络响应、或者其他状态变化，使组件动态的响应并改变组件的输出。

状态与属性十分相似，但是状态是私有的，完全受控于当前组件。没有状态的组件可以直接用纯函数。


1. 构造函数是唯一能够初始化 this.state 的地方。
1. 应当使用 setState() 更新状态
1. this.props 和 this.state 可能是异步更新的,如果依赖上个state或props需使用function
1. 当调用 setState() 时，React 将你提供的对象合并到当前状态。
1. 组件可以选择将其状态作为属性传递给其子组件

在 React 应用程序中，组件是有状态还是无状态 根据可能随时间而变化的组件。

## Event

```html
<!-- 传统html -->
<button onclick="activateLasers()">
  Activate Lasers
</button>

<!-- react组件 -->
<button onClick={activateLasers}>
  Activate Lasers
</button>
```

```js
// 传统方式阻止默认行为
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>

// react 纯函数中阻止默认行为
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}

// react 中 class的事件1
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
// react 中 class的事件2
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={e=>this.handleClick()}>
        Click me
      </button>
    );
  }
}
```