# 简介

[官方文档](https://doc.react-china.org/docs/hello-world.html)

## 准备

`npm i -S react react-dom`

`npm i babel-loader babel-preset-react babel-plugin-import -S`

```js
module: {
    rules: [{
        test: /\.(js|jsx)$/,
        loader: 'babel-loader',
        options: {
            presets: ['react']
        },
        exclude: /node_modules/
    }]
},
externals: {
    'react': 'React',
    'react-dom': 'ReactDOM'
},
```

```js
import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
    <h1>Hello, world!</h1>,
    document.getElementById('root')
);
```

## 组件

```js
class HelloMessage extends React.Component {
    render() {
        return (
            <div>Hello {this.props.name}</div>
        )
    }
}

ReactDOM.render(
    <HelloMessage name="World" />,
    document.getElementById('root')
);
```

## JSX

写 JSX 的时候一般都会带上换行和缩进，这样可以增强代码的可读性

推荐在 JSX 代码的外面扩上一个小括号，这样可以防止 分号自动插入 的 bug

`const element = <img src={user.avatarUrl}></img>;`

当使用大括号包裹的 JavaScript 表达式时就不要再到外面套引号了。JSX 会将引号当中的内容识别为字符串而不是表达式。

`class tabindex` => `className tabIndex`

因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称

`const element = <h1>{title}</h1>;` // title 可直接使用

JSX 防注入攻击,防止 XSS(跨站脚本) 攻击。

```js
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
```

```js
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
);
```

```js
// 注意: 以下示例是简化过的（不代表在 React 源码中是这样）
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};
```

Babel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用

## 属性(props)

无论是使用函数或是类来声明一个组件，它决不能修改它自己的props。

```js
// 纯函数
function sum(a, b) {
  return a + b;
}

// 非纯函数
function withdraw(account, amount) {
  account.total -= amount;
}
```

所有的React组件必须像纯函数那样使用它们的props。

无状态函数（stateless function）

## 状态(state)

应用的界面是随时间动态变化的.

state可以在不违反上述规则的情况下，根据用户操作、网络响应、或者其他状态变化，使组件动态的响应并改变组件的输出。

状态与属性十分相似，但是状态是私有的，完全受控于当前组件。没有状态的组件可以直接用纯函数。


1. 构造函数是唯一能够初始化 this.state 的地方。
1. 应当使用 setState() 更新状态
1. this.props 和 this.state 可能是异步更新的,如果依赖上个state或props需使用function
1. 当调用 setState() 时，React 将你提供的对象合并到当前状态。
1. 组件可以选择将其状态作为属性传递给其子组件

在 React 应用程序中，组件是有状态还是无状态 根据可能随时间而变化的组件。

属性是公开的，状态是私有的。

## Event

```html
<!-- 传统html -->
<button onclick="activateLasers()">
  Activate Lasers
</button>

<!-- react组件 -->
<button onClick={activateLasers}>
  Activate Lasers
</button>
```

```js
// 传统方式阻止默认行为
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>

// react 纯函数中阻止默认行为
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}

// react 中 class的事件1
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
// react 中 class的事件2
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={e=>this.handleClick()}>
        Click me
      </button>
    );
  }
}
```

## Keys

Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。

元素的key只有在它和它的兄弟节点对比时才有意义。

元素的key在他的兄弟元素之间应该唯一,不需要是全局唯一。

```js
function ListItem(props) {
  // 对啦！这里不需要指定key:
  return <li>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // 又对啦！key应该在数组的上下文中被指定
    <ListItem key={number.toString()}
              value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
```

## 表单

### 受控组件

使用受控组件要为数据可能发生变化的每一种方式编写一个事件处理程序，并通过一个组件来管理全部的状态。

```js
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={e=>this.handleSubmit(e)}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={e=>this.handleChange(e)} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

### 非受控组件

在大多数情况下，我们推荐使用 受控组件 来实现表单。 

在受控组件中，表单数据由 React 组件处理。如果让表单数据由 DOM 处理时，替代方案为使用非受控组件。

使用 ref 从 DOM 获取表单值。

```js
class NameForm extends React.Component {
  constructor(props) {
    super(props);
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={e=>this.handleSubmit(e)}>
        <label>
          Name:
          <input type="text" ref={(input) => this.input = input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

## 组合

React 推荐组件使用组合 而不是 继承的方式。

1. 包含：`props.children`
1. 特殊实例：

```js
function Dialog(props){
  return (
    <div>
    {props.title}
    </div>
  )
}

function WelcomeDialog(){
  return (
    <Dialog title="welcome"/>
  )
}
```

